<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VoiceLooper Web</title>
  <style>
    body { font-family: Arial, sans-serif; background-color: #121212; color: #fff; margin:0; padding:20px; }
    .controls { margin-bottom: 10px; }
    .track { background: #1e1e1e; border: 1px solid #444; padding: 10px; margin-bottom: 5px; display: flex; align-items: center; }
    .track button { margin-right: 5px; }
  </style>
</head>
<body>
  <h1>VoiceLooper Web</h1>
  <div class="controls">
    BPM: <input id="bpmInput" type="number" value="120" min="40" max="200" style="width:60px;">
    Quantize <input id="quantizeToggle" type="checkbox" checked>
    <button id="metronomeBtn">Start Metronome</button>
  </div>
  <div id="tracks"></div>

<script>
  const numTracks = 10;
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const tracks = [];
  let metronomeInterval = null;
  let quantizeOn = true;
  
  document.getElementById('quantizeToggle').addEventListener('change', (e) => {
    quantizeOn = e.target.checked;
  });

  function createTrack(index) {
    const track = {
      index: index,
      buffer: null,
      source: null,
      recording: false,
      chunks: [],
      recorder: null,
      mute: false
    };
    tracks.push(track);

    const div = document.createElement('div');
    div.className = 'track';
    div.id = 'track' + index;

    div.innerHTML = `
      <span style="width:70px;">Track ${index + 1}</span>
      <button class="recBtn">Rec</button>
      <button class="playBtn" disabled>Play</button>
      <button class="deleteBtn" disabled>Delete</button>
      <button class="fxBtn" disabled>FX</button>
      <button class="muteBtn" disabled>Mute</button>
    `;

    document.getElementById('tracks').appendChild(div);

    const recBtn = div.querySelector('.recBtn');
    const playBtn = div.querySelector('.playBtn');
    const deleteBtn = div.querySelector('.deleteBtn');
    const fxBtn = div.querySelector('.fxBtn');
    const muteBtn = div.querySelector('.muteBtn');

    recBtn.addEventListener('click', () => toggleRecord(track, recBtn, playBtn, deleteBtn, fxBtn, muteBtn));
    playBtn.addEventListener('click', () => togglePlay(track, playBtn));
    deleteBtn.addEventListener('click', () => deleteTrack(track, playBtn, deleteBtn, fxBtn, muteBtn));
    fxBtn.addEventListener('click', () => showEffectPrompt(track));
    muteBtn.addEventListener('click', () => toggleMute(track, muteBtn));
  }

  async function toggleRecord(track, recBtn, playBtn, deleteBtn, fxBtn, muteBtn) {
    if (track.recording) {
      track.recorder.stop();
      recBtn.textContent = 'Rec';
      track.recording = false;
      return;
    }
    // Start recording
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    track.recorder = new MediaRecorder(stream);
    track.chunks = [];
    track.recorder.ondataavailable = e => {
      if (e.data && e.data.size > 0) {
        track.chunks.push(e.data);
      }
    };
    track.recorder.onstop = async () => {
      const blob = new Blob(track.chunks, { type: 'audio/webm' });
      const arrayBuffer = await blob.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      let finalBuffer = audioBuffer;
      if (quantizeOn) {
        const bpm = parseFloat(document.getElementById('bpmInput').value);
        const beatSamples = Math.round((60 / bpm) * audioBuffer.sampleRate);
        const quantizedLength = Math.ceil(audioBuffer.length / beatSamples) * beatSamples;
        finalBuffer = audioContext.createBuffer(audioBuffer.numberOfChannels, quantizedLength, audioBuffer.sampleRate);
        for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
          const data = audioBuffer.getChannelData(ch);
          finalBuffer.getChannelData(ch).set(data.slice(0, quantizedLength));
        }
      }
      track.buffer = finalBuffer;
      playBtn.disabled = false;
      deleteBtn.disabled = false;
      fxBtn.disabled = false;
      muteBtn.disabled = false;
    };
    track.recorder.start();
    track.recording = true;
    recBtn.textContent = 'Stop';
  }

  function togglePlay(track, playBtn) {
    if (track.source) {
      track.source.stop();
      track.source = null;
      playBtn.textContent = 'Play';
      return;
    }
    if (!track.buffer) return;
    const source = audioContext.createBufferSource();
    source.buffer = track.buffer;
    source.loop = true;
    source.connect(audioContext.destination);
    source.start();
    track.source = source;
    playBtn.textContent = 'Stop';
  }

  function deleteTrack(track, playBtn, deleteBtn, fxBtn, muteBtn) {
    if (track.source) {
      track.source.stop();
      track.source = null;
    }
    track.buffer = null;
    playBtn.disabled = true;
    deleteBtn.disabled = true;
    fxBtn.disabled = true;
    muteBtn.disabled = true;
  }

  function toggleMute(track, muteBtn) {
    track.mute = !track.mute;
    if (track.source) {
      if (track.mute) {
        track.source.disconnect();
        muteBtn.textContent = 'Unmute';
      } else {
        track.source.connect(audioContext.destination);
        muteBtn.textContent = 'Mute';
      }
    }
  }

  function showEffectPrompt(track) {
    if (!track.buffer) return;
    const effect = prompt('Enter effect: reverb, delay, pitchUp, pitchDown, loFi');
    if (!effect) return;
    applyEffect(track, effect);
  }

  function applyEffect(track, effect) {
    const offline = new OfflineAudioContext(track.buffer.numberOfChannels, track.buffer.length, track.buffer.sampleRate);
    const bufferSource = offline.createBufferSource();
    bufferSource.buffer = track.buffer;
    let finalNode = bufferSource;

    if (effect === 'reverb') {
      const convolver = offline.createConvolver();
      const impulse = offline.createBuffer(1, offline.sampleRate * 3, offline.sampleRate);
      const impulseData = impulse.getChannelData(0);
      for (let i = 0; i < impulseData.length; i++) {
        impulseData[i] = (Math.random() * 2 - 1) * (1 - i / impulseData.length);
      }
      convolver.buffer = impulse;
      finalNode.connect(convolver);
      finalNode = convolver;
    } else if (effect === 'delay') {
      const delay = offline.createDelay();
      delay.delayTime.value = 0.25;
      const feedback = offline.createGain();
      feedback.gain.value = 0.5;
      finalNode.connect(delay).connect(feedback).connect(delay);
      finalNode = delay;
    } else if (effect === 'pitchUp' || effect === 'pitchDown') {
      const ratio = effect === 'pitchUp' ? 1.25 : 0.8;
      bufferSource.playbackRate.value = ratio;
    } else if (effect === 'loFi') {
      // simple bitcrusher effect: downsample by factor of 4
      const processor = offline.createScriptProcessor(0, track.buffer.numberOfChannels, track.buffer.numberOfChannels);
      processor.onaudioprocess = function(e) {
        for (let ch = 0; ch < e.outputBuffer.numberOfChannels; ch++) {
          const input = e.inputBuffer.getChannelData(ch);
          const output = e.outputBuffer.getChannelData(ch);
          for (let i = 0; i < input.length; i += 4) {
            const sample = input[i];
            output[i] = sample;
            output[i + 1] = sample;
            output[i + 2] = sample;
            output[i + 3] = sample;
          }
        }
      };
      finalNode.connect(processor);
      finalNode = processor;
    }

    finalNode.connect(offline.destination);
    bufferSource.start();
    offline.startRendering().then(renderedBuffer => {
      track.buffer = renderedBuffer;
    });
  }
  document.getElementById('metronomeBtn').addEventListener('click', () => {
    if (metronomeInterval) {
      clearInterval(metronomeInterval);
      metronomeInterval = null;
      document.getElementById('metronomeBtn').textContent = 'Start Metronome';
    } else {
      const bpm = parseFloat(document.getElementById('bpmInput').value);
      const interval = 60000 / bpm;
      const clickContext = new (window.AudioContext || window.webkitAudioContext)();
      const playClick = () => {
        const osc = clickContext.createOscillator();
        const gain = clickContext.createGain();
        osc.connect(gain).connect(clickContext.destination);
        osc.frequency.value = 1000;
        gain.gain.setValueAtTime(0.3, clickContext.currentTime);
        osc.start();
        osc.stop(clickContext.currentTime + 0.05);
      };
      playClick();
      metronomeInterval = setInterval(playClick, interval);
      document.getElementById('metronomeBtn').textContent = 'Stop Metronome';
    }
  });

  // Initialize tracks
  for (let i = 0; i < numTracks; i++) {
    createTrack(i);
  }
</script>
</body>
</html>
