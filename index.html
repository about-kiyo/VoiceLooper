<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VoiceLooper Web</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #eee;
            margin: 0;
            padding: 20px;
        }
        .controls {
            margin-bottom: 10px;
        }
        label {
            margin-right: 5px;
        }
        input[type="number"], select, input[type="range"] {
            margin-right: 10px;
        }
        .track {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            background: #1e1e1e;
            padding: 8px;
            border-radius: 4px;
        }
        .track button {
            margin-right: 5px;
        }
        .slider {
            width: 100px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>VoiceLooper Web</h1>
    <div class="controls">
        <label for="bpmInput">BPM:</label>
        <input type="number" id="bpmInput" value="120" min="20" max="300">
        <label for="quantizeChk">Quantize</label>
        <input type="checkbox" id="quantizeChk" checked>
        <button id="metronomeBtn">Start Metronome</button>
        <button id="playAllBtn" disabled>Play All</button>
        <button id="stopAllBtn" disabled>Stop All</button>
        <button id="addTrackBtn">+ Add Track</button>
    </div>
    <div id="tracksContainer"></div>

    <script>
    const maxTracks = 10;
    let trackCount = 3; // initial visible tracks
    const tracks = [];
    let audioCtx;
    let metronomeInterval;
    let metronomeOsc;
    function getAudioContext() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioCtx;
    }
    class Track {
        constructor(index) {
            this.index = index;
            this.recBtn = null;
            this.playBtn = null;
            this.deleteBtn = null;
            this.muteBtn = null;
            this.effectSelect = null;
            this.effectAmount = null;
            this.volumeSlider = null;
            this.gainNode = null;
            this.source = null;
            this.mediaRecorder = null;
            this.mediaStream = null;
            this.recordedChunks = [];
            this.buffer = null;
            this.processedBuffer = null;
            this.isRecording = false;
            this.isPlaying = false;
            this.isMuted = false;
            this.render();
        }
        render() {
            const container = document.createElement('div');
            container.className = 'track';
            container.id = 'track-' + this.index;
            const label = document.createElement('span');
            label.textContent = 'Track ' + this.index;
            label.style.width = '70px';
            container.appendChild(label);
            this.recBtn = document.createElement('button');
            this.recBtn.textContent = 'Rec';
            this.recBtn.addEventListener('click', () => this.toggleRec());
            container.appendChild(this.recBtn);
            this.playBtn = document.createElement('button');
            this.playBtn.textContent = 'Play';
            this.playBtn.disabled = true;
            this.playBtn.addEventListener('click', () => this.togglePlay());
            container.appendChild(this.playBtn);
            this.deleteBtn = document.createElement('button');
            this.deleteBtn.textContent = 'Del';
            this.deleteBtn.disabled = true;
            this.deleteBtn.addEventListener('click', () => this.deleteTrack());
            container.appendChild(this.deleteBtn);
            this.effectSelect = document.createElement('select');
            ['none','reverb','delay','pitchUp','pitchDown','lofi'].forEach(opt => {
                const option = document.createElement('option');
                option.value = opt;
                option.textContent = opt;
                this.effectSelect.appendChild(option);
            });
            this.effectSelect.disabled = true;
            this.effectSelect.addEventListener('change', () => this.applyEffect());
            container.appendChild(this.effectSelect);
            this.effectAmount = document.createElement('input');
            this.effectAmount.type = 'range';
            this.effectAmount.min = 0; this.effectAmount.max = 1; this.effectAmount.step = 0.01;
            this.effectAmount.value = 0.5;
            this.effectAmount.className = 'slider';
            this.effectAmount.disabled = true;
            this.effectAmount.addEventListener('input', () => this.applyEffect());
            container.appendChild(this.effectAmount);
            this.volumeSlider = document.createElement('input');
            this.volumeSlider.type = 'range';
            this.volumeSlider.min = 0; this.volumeSlider.max = 1; this.volumeSlider.step = 0.01;
            this.volumeSlider.value = 1;
            this.volumeSlider.className = 'slider';
            this.volumeSlider.disabled = true;
            this.volumeSlider.addEventListener('input', () => this.updateVolume());
            container.appendChild(this.volumeSlider);
            this.muteBtn = document.createElement('button');
            this.muteBtn.textContent = 'Mute';
            this.muteBtn.disabled = true;
            this.muteBtn.addEventListener('click', () => this.toggleMute());
            container.appendChild(this.muteBtn);
            document.getElementById('tracksContainer').appendChild(container);
        }
        async toggleRec() {
            if (this.isRecording) {
                this.stopRec();
            } else {
                await this.startRec();
            }
        }
        async startRec() {
            const ctx = getAudioContext();
            this.isRecording = true;
            this.recBtn.textContent = 'Stop';
            // Disable controls while recording
            this.playBtn.disabled = true;
            this.deleteBtn.disabled = true;
            this.effectSelect.disabled = true;
            this.effectAmount.disabled = true;
            this.volumeSlider.disabled = true;
            this.muteBtn.disabled = true;
            try {
                this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.mediaRecorder = new MediaRecorder(this.mediaStream);
                this.recordedChunks = [];
                this.mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) {
                        this.recordedChunks.push(e.data);
                    }
                };
                this.mediaRecorder.onstop = async () => {
                    try {
                        const blob = new Blob(this.recordedChunks);
                        const arrayBuffer = await blob.arrayBuffer();
                        this.buffer = await ctx.decodeAudioData(arrayBuffer);
                        const quantizeFlag = document.getElementById('quantizeChk').checked;
                        if (quantizeFlag) {
                            const bpm = parseFloat(document.getElementById('bpmInput').value);
                            this.buffer = quantizeBuffer(this.buffer, bpm);
                        }
                        this.processedBuffer = this.buffer;
                    } catch (err) {
                        console.error('Decoding failed', err);
                        this.buffer = null;
                        this.processedBuffer = null;
                    }
                    // Reset recording state
                    this.isRecording = false;
                    this.recBtn.textContent = 'Rec';
                    this.playBtn.disabled = !this.buffer;
                    this.deleteBtn.disabled = !this.buffer;
                    this.effectSelect.disabled = !this.buffer;
                    this.effectAmount.disabled = !this.buffer;
                    this.volumeSlider.disabled = !this.buffer;
                    this.muteBtn.disabled = !this.buffer;
                    this.updateVolume();
                    this.updateGlobalButtons();
                    // Clean up mic
                    if (this.mediaStream) {
                        this.mediaStream.getTracks().forEach(t => t.stop());
                    }
                };
                this.mediaRecorder.start();
            } catch (err) {
                console.error('Error during recording', err);
                this.isRecording = false;
                this.recBtn.textContent = 'Rec';
            }
        }
        stopRec() {
            if (this.mediaRecorder && this.isRecording) {
                try {
                    this.mediaRecorder.stop();
                } catch (e) {
                    console.error('Error stopping recorder', e);
                }
            }
        }
        togglePlay() {
            if (!this.buffer) return;
            if (this.isPlaying) {
                this.stopPlay();
            } else {
                this.startPlay();
            }
        }
        startPlay() {
            const ctx = getAudioContext();
            const buffer = this.processedBuffer || this.buffer;
            this.gainNode = ctx.createGain();
            this.gainNode.gain.value = this.isMuted ? 0 : this.volumeSlider.value;
            this.source = ctx.createBufferSource();
            this.source.buffer = buffer;
            this.source.loop = true;
            this.source.connect(this.gainNode).connect(ctx.destination);
            this.source.start();
            this.isPlaying = true;
            this.playBtn.textContent = 'Stop';
            this.updateGlobalButtons();
        }
        stopPlay() {
            if (!this.isPlaying) return;
            this.source.stop();
            this.isPlaying = false;
            this.playBtn.textContent = 'Play';
            this.updateGlobalButtons();
        }
        deleteTrack() {
            this.stopPlay();
            const elem = document.getElementById('track-' + this.index);
            if (elem) elem.remove();
            const idx = tracks.indexOf(this);
            if (idx > -1) tracks.splice(idx, 1);
            updateGlobalButtons();
        }
        toggleMute() {
            if (!this.gainNode) return;
            this.isMuted = !this.isMuted;
            this.gainNode.gain.value = this.isMuted ? 0 : this.volumeSlider.value;
            this.muteBtn.textContent = this.isMuted ? 'Unmute' : 'Mute';
        }
        updateVolume() {
            if (this.gainNode) {
                this.gainNode.gain.value = this.volumeSlider.value;
                if (this.isMuted) {
                    this.isMuted = false;
                    this.muteBtn.textContent = 'Mute';
                }
            }
        }
        applyEffect() {
            if (!this.buffer) return;
            const type = this.effectSelect.value;
            const amount = parseFloat(this.effectAmount.value);
            this.processedBuffer = applyEffectToBuffer(this.buffer, type, amount);
            if (this.isPlaying) {
                this.stopPlay();
                this.startPlay();
            }
        }
        updateGlobalButtons() {
            // placeholder; replaced below
        }
    }
    function applyEffectToBuffer(buffer, type, amount) {
        const ctx = getAudioContext();
        if (!type || type === 'none') return buffer;
        const channels = buffer.numberOfChannels;
        const length = buffer.length;
        const sampleRate = buffer.sampleRate;
        const newBuffer = ctx.createBuffer(channels, length, sampleRate);
        for (let ch = 0; ch < channels; ch++) {
            const input = buffer.getChannelData(ch);
            const output = newBuffer.getChannelData(ch);
            switch (type) {
                case 'reverb': {
                    const decay = amount * 2;
                    const rev = new Float32Array(length);
                    for (let i = 0; i < length; i++) {
                        rev[i] = input[i];
                        if (i > 0) rev[i] += decay * rev[i - 1];
                        output[i] = (1 - amount) * input[i] + amount * rev[i];
                    }
                    break;
                }
                case 'delay': {
                    const delaySamples = Math.floor(sampleRate * amount * 0.5);
                    for (let i = 0; i < length; i++) {
                        const delayedIndex = i - delaySamples;
                        const delayed = delayedIndex >= 0 ? input[delayedIndex] : 0;
                        output[i] = (1 - amount) * input[i] + amount * delayed;
                    }
                    break;
                }
                case 'pitchUp':
                case 'pitchDown': {
                    const factor = type === 'pitchUp' ? 1 + amount : 1 - amount * 0.5;
                    for (let i = 0; i < length; i++) {
                        const srcIndex = i / factor;
                        const lower = Math.floor(srcIndex);
                        const frac = srcIndex - lower;
                        const samp = input[lower] || 0;
                        const next = input[lower + 1] || 0;
                        output[i] = samp * (1 - frac) + next * frac;
                    }
                    break;
                }
                case 'lofi': {
                    const step = Math.floor((1 / (amount + 0.0001)) * 50);
                    for (let i = 0; i < length; i++) {
                        if (i % step === 0) {
                            output[i] = input[i];
                        } else {
                            output[i] = output[i - 1] || 0;
                        }
                    }
                    break;
                }
            }
        }
        return newBuffer;
    }
    function quantizeBuffer(buffer, bpm) {
        const ctx = getAudioContext();
        const secondsPerBeat = 60 / bpm;
        const samplesPerBeat = buffer.sampleRate * secondsPerBeat;
        const beats = Math.round(buffer.length / samplesPerBeat);
        const newLength = Math.ceil(beats * samplesPerBeat);
        const newBuffer = ctx.createBuffer(buffer.numberOfChannels, newLength, buffer.sampleRate);
        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
            const src = buffer.getChannelData(ch);
            const dst = newBuffer.getChannelData(ch);
            dst.set(src, 0);
            for (let i = src.length; i < newLength; i++) {
                dst[i] = 0;
            }
        }
        return newBuffer;
    }
    function updateGlobalButtons() {
        const playAll = document.getElementById('playAllBtn');
        const stopAll = document.getElementById('stopAllBtn');
        playAll.disabled = !tracks.some(t => t.buffer);
        stopAll.disabled = !tracks.some(t => t.isPlaying);
    }
    function addTrack() {
        const nextIndex = trackCount + 1;
        if (nextIndex > maxTracks) return;
        const t = new Track(nextIndex);
        tracks.push(t);
        trackCount = nextIndex;
        updateGlobalButtons();
    }
    for (let i = 1; i <= trackCount; i++) {
        const t = new Track(i);
        tracks.push(t);
    }
    document.getElementById('playAllBtn').addEventListener('click', () => {
        tracks.forEach(t => {
            if (t.buffer && !t.isPlaying) t.startPlay();
        });
        updateGlobalButtons();
    });
    document.getElementById('stopAllBtn').addEventListener('click', () => {
        tracks.forEach(t => {
            if (t.isPlaying) t.stopPlay();
        });
        updateGlobalButtons();
    });
    document.getElementById('addTrackBtn').addEventListener('click', () => {
        addTrack();
    });
    document.getElementById('metronomeBtn').addEventListener('click', () => {
        const btn = document.getElementById('metronomeBtn');
        if (!metronomeInterval) {
            const bpm = parseFloat(document.getElementById('bpmInput').value);
            const ctx = getAudioContext();
            metronomeOsc = ctx.createOscillator();
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.1, ctx.currentTime);
            metronomeOsc.connect(gain).connect(ctx.destination);
            metronomeOsc.type = 'square';
            metronomeOsc.frequency.value = 1000;
            metronomeOsc.start();
            const interval = (60 / bpm) * 1000;
            metronomeInterval = setInterval(() => {
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.05);
            }, interval);
            btn.textContent = 'Stop Metronome';
        } else {
            clearInterval(metronomeInterval);
            if (metronomeOsc) {
                metronomeOsc.stop();
            }
            metronomeInterval = null;
            btn.textContent = 'Start Metronome';
        }
    });
    Track.prototype.updateGlobalButtons = updateGlobalButtons;
    </script>
</body>
</html>
