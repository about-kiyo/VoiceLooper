<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VoiceLooper Web</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #eee;
            margin: 0;
            padding: 20px;
        }
        .controls {
            margin-bottom: 10px;
        }
        label {
            margin-right: 5px;
        }
        input[type="number"], select, input[type="range"] {
            margin-right: 10px;
        }
        .track {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            background: #1e1e1e;
            padding: 8px;
            border-radius: 4px;
        }
        .track button {
            margin-right: 5px;
        }
        .slider {
            width: 100px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>VoiceLooper Web</h1>
    <div class="controls">
        <label for="bpmInput">BPM:</label>
        <input type="number" id="bpmInput" value="120" min="20" max="300">
        <label for="quantizeChk">Quantize</label>
        <input type="checkbox" id="quantizeChk" checked>
        <button id="metronomeBtn">Start Metronome</button>
        <button id="playAllBtn" disabled>Play All</button>
        <button id="stopAllBtn" disabled>Stop All</button>
        <button id="addTrackBtn">+ Add Track</button>
    </div>
    <div id="tracksContainer"></div>

    <script>
    const maxTracks = 10;
    let trackCount = 3; // initial visible tracks
    const tracks = [];
    let audioCtx;
    let metronomeInterval;
    let metronomeOsc;
    // Utility: Ensure audio context exists
    function getAudioContext() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioCtx;
    }

    class Track {
        constructor(index) {
            this.index = index;
            this.recBtn = null;
            this.playBtn = null;
            this.deleteBtn = null;
            this.muteBtn = null;
            this.effectSelect = null;
            this.effectAmount = null;
            this.volumeSlider = null;
            this.gainNode = null;
            this.buffer = null;
            this.processedBuffer = null;
            this.isRecording = false;
            this.isPlaying = false;
            this.isMuted = false;
            this.recorder = null;
            this.initUI();
        }
        initUI() {
            const container = document.createElement('div');
            container.className = 'track';
            container.id = 'track-' + this.index;

            const label = document.createElement('span');
            label.textContent = `Track ${this.index + 1}`;
            label.style.minWidth = '70px';
            container.appendChild(label);

            this.recBtn = document.createElement('button');
            this.recBtn.textContent = 'Rec';
            this.recBtn.addEventListener('click', () => this.toggleRec());
            container.appendChild(this.recBtn);

            this.playBtn = document.createElement('button');
            this.playBtn.textContent = 'Play';
            this.playBtn.disabled = true;
            this.playBtn.addEventListener('click', () => this.togglePlay());
            container.appendChild(this.playBtn);

            this.deleteBtn = document.createElement('button');
            this.deleteBtn.textContent = 'Del';
            this.deleteBtn.disabled = true;
            this.deleteBtn.addEventListener('click', () => this.deleteTrack());
            container.appendChild(this.deleteBtn);

            // Effect selection
            this.effectSelect = document.createElement('select');
            ['none', 'reverb', 'delay', 'pitchUp', 'pitchDown', 'lofi'].forEach(opt => {
                const option = document.createElement('option');
                option.value = opt;
                option.textContent = opt;
                this.effectSelect.appendChild(option);
            });
            this.effectSelect.disabled = true;
            this.effectSelect.addEventListener('change', () => this.applyEffect());
            container.appendChild(this.effectSelect);

            // Effect amount slider
            this.effectAmount = document.createElement('input');
            this.effectAmount.type = 'range';
            this.effectAmount.min = 0; this.effectAmount.max = 1; this.effectAmount.step = 0.01;
            this.effectAmount.value = 0.5;
            this.effectAmount.className = 'slider';
            this.effectAmount.disabled = true;
            this.effectAmount.addEventListener('input', () => this.applyEffect());
            container.appendChild(this.effectAmount);

            // Volume slider
            this.volumeSlider = document.createElement('input');
            this.volumeSlider.type = 'range';
            this.volumeSlider.min = 0; this.volumeSlider.max = 1; this.volumeSlider.step = 0.01;
            this.volumeSlider.value = 1;
            this.volumeSlider.className = 'slider';
            this.volumeSlider.disabled = true;
            this.volumeSlider.addEventListener('input', () => this.updateVolume());
            container.appendChild(this.volumeSlider);

            this.muteBtn = document.createElement('button');
            this.muteBtn.textContent = 'Mute';
            this.muteBtn.disabled = true;
            this.muteBtn.addEventListener('click', () => this.toggleMute());
            container.appendChild(this.muteBtn);

            document.getElementById('tracksContainer').appendChild(container);
        }
        async toggleRec() {
            if (this.isRecording) {
                this.stopRec();
            } else {
                await this.startRec();
            }
        }
        async startRec() {
            const ctx = getAudioContext();
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.mediaStream = stream;
                this.mediaSource = ctx.createMediaStreamSource(stream);
                const recorder = new MediaRecorder(stream);
                this.recorder = recorder;
                const chunks = [];
                recorder.ondataavailable = evt => chunks.push(evt.data);
                recorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    const arrayBuffer = await blob.arrayBuffer();
                    ctx.decodeAudioData(arrayBuffer).then(decoded => {
                        const quantize = document.getElementById('quantizeChk').checked;
                        const bpm = parseFloat(document.getElementById('bpmInput').value);
                        this.buffer = quantize ? quantizeBuffer(decoded, bpm, ctx) : decoded;
                        this.processedBuffer = this.buffer;
                        this.recBtn.textContent = 'Rec';
                        this.recBtn.disabled = false;
                        this.playBtn.disabled = false;
                        this.deleteBtn.disabled = false;
                        this.effectSelect.disabled = false;
                        this.effectAmount.disabled = false;
                        this.volumeSlider.disabled = false;
                        this.muteBtn.disabled = false;
                        this.updateGlobalButtons();
                    });
                };
                recorder.start();
                this.recBtn.textContent = 'Stop';
                this.isRecording = true;
                recorder.ondataavailable = evt => chunks.push(evt.data);
                recorder.onstop = () => { this.isRecording = false; stream.getTracks().forEach(t => t.stop()); };
                setTimeout(() => {}, 0);
            } catch (err) {
                console.error(err);
            }
        }
        stopRec() {
            if (this.recorder) {
                this.recorder.stop();
            }
        }
        togglePlay() {
            if (!this.buffer) return;
            if (this.isPlaying) {
                this.stopPlay();
            } else {
                this.startPlay();
            }
        }
        startPlay() {
            const ctx = getAudioContext();
            // ensure processed buffer
            const bufferToUse = this.processedBuffer || this.buffer;
            this.source = ctx.createBufferSource();
            this.source.buffer = bufferToUse;
            if (!this.gainNode) this.gainNode = ctx.createGain();
            this.source.connect(this.gainNode).connect(ctx.destination);
            this.gainNode.gain.value = this.volumeSlider.value;
            this.source.loop = true;
            this.source.start();
            this.isPlaying = true;
            this.playBtn.textContent = 'Stop';
            this.updateGlobalButtons();
        }
        stopPlay() {
            if (this.source) {
                this.source.stop();
                this.source.disconnect();
                this.source = null;
            }
            this.isPlaying = false;
            this.playBtn.textContent = 'Play';
            this.updateGlobalButtons();
        }
        deleteTrack() {
            this.stopRec();
            this.stopPlay();
            const trackElem = document.getElementById('track-' + this.index);
            trackElem.remove();
            tracks.splice(tracks.indexOf(this), 1);
            this.updateGlobalButtons();
        }
        toggleMute() {
            if (!this.gainNode) return;
            this.isMuted = !this.isMuted;
            this.gainNode.gain.value = this.isMuted ? 0 : this.volumeSlider.value;
            this.muteBtn.textContent = this.isMuted ? 'Unmute' : 'Mute';
        }
        updateVolume() {
            if (this.gainNode) {
                this.gainNode.gain.value = this.volumeSlider.value;
                if (this.isMuted) {
                    this.muteBtn.textContent = 'Unmute';
                    this.isMuted = false;
                }
            }
        }
        applyEffect() {
            if (!this.buffer) return;
            const type = this.effectSelect.value;
            const amount = parseFloat(this.effectAmount.value);
            this.processedBuffer = applyEffectToBuffer(this.buffer, type, amount);
            if (this.isPlaying) {
                this.stopPlay();
                this.startPlay();
            }
        }
        updateGlobalButtons() {
            // dummy placeholder; actual implementation below in global scope
        }
    }

    function applyEffectToBuffer(buffer, type, amount) {
        // Return new buffer based on effect; simple implementations
        const ctx = getAudioContext();
        if (type === 'none') return buffer;
        const numChannels = buffer.numberOfChannels;
        const length = buffer.length;
        const sampleRate = buffer.sampleRate;
        const newBuffer = ctx.createBuffer(numChannels, length, sampleRate);
        for (let ch = 0; ch < numChannels; ch++) {
            const input = buffer.getChannelData(ch);
            const output = newBuffer.getChannelData(ch);
            switch (type) {
                case 'reverb': {
                    const decay = amount * 2; // up to 2s
                    const reverbBuffer = new Float32Array(length);
                    for (let i = 0; i < length; i++) {
                        reverbBuffer[i] = input[i];
                        if (i > 0) {
                            reverbBuffer[i] += decay * reverbBuffer[i - 1];
                        }
                        // mix original and reverb
                        output[i] = (1 - amount) * input[i] + amount * reverbBuffer[i];
                    }
                    break;
                }
                case 'delay': {
                    const delaySamples = Math.floor(sampleRate * amount * 0.5); // up to 0.5s
                    for (let i = 0; i < length; i++) {
                        const delayedIndex = i - delaySamples;
                        const delayed = delayedIndex >= 0 ? input[delayedIndex] : 0;
                        output[i] = (1 - amount) * input[i] + amount * delayed;
                    }
                    break;
                }
                case 'pitchUp':
                case 'pitchDown': {
                    const shiftFactor = type === 'pitchUp' ? (1 + amount) : (1 - amount * 0.5);
                    for (let i = 0; i < length; i++) {
                        const srcIndex = i / shiftFactor;
                        const lower = Math.floor(srcIndex);
                        const frac = srcIndex - lower;
                        const sample = (input[lower] || 0);
                        const nextSample = (input[lower + 1] || 0);
                        const shifted = sample * (1 - frac) + nextSample * frac;
                        output[i] = shifted;
                    }
                    break;
                }
                case 'lofi': {
                    const step = Math.floor((1 / (amount + 0.0001)) * 50);
                    for (let i = 0; i < length; i++) {
                        if (i % step === 0) {
                            output[i] = input[i];
                        } else {
                            output[i] = output[i - 1] || 0;
                        }
                    }
                    break;
                }
            }
        }
        return newBuffer;
    }

    function quantizeBuffer(buffer, bpm, ctx) {
        // trim and pad buffer to nearest beat
        const beatLengthSec = 60 / bpm;
        const bufferLengthSec = buffer.duration;
        const beats = Math.round(bufferLengthSec / beatLengthSec);
        const newLength = Math.max(1, beats) * beatLengthSec;
        const numSamples = Math.floor(newLength * buffer.sampleRate);
        const newBuffer = ctx.createBuffer(buffer.numberOfChannels, numSamples, buffer.sampleRate);
        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
            const src = buffer.getChannelData(ch);
            const dest = newBuffer.getChannelData(ch);
            for (let i = 0; i < numSamples; i++) {
                dest[i] = src[i] || 0;
            }
        }
        return newBuffer;
    }

    // Global Play/Stop buttons update
    function updateGlobalButtons() {
        const playAllBtn = document.getElementById('playAllBtn');
        const stopAllBtn = document.getElementById('stopAllBtn');
        const anyBuffer = tracks.some(t => t.buffer);
        const anyPlaying = tracks.some(t => t.isPlaying);
        playAllBtn.disabled = !anyBuffer || anyPlaying;
        stopAllBtn.disabled = !anyPlaying;
    }

    // Create track
    function addTrack() {
        if (tracks.length >= maxTracks) return;
        const newTrack = new Track(tracks.length);
        tracks.push(newTrack);
        updateGlobalButtons();
    }

    // Initialize default tracks
    for (let i = 0; i < trackCount; i++) {
        addTrack();
    }

    // Event listeners for global buttons
    document.getElementById('playAllBtn').addEventListener('click', () => {
        tracks.forEach(t => { if (t.buffer && !t.isPlaying) t.startPlay(); });
        updateGlobalButtons();
    });
    document.getElementById('stopAllBtn').addEventListener('click', () => {
        tracks.forEach(t => { if (t.isPlaying) t.stopPlay(); });
        updateGlobalButtons();
    });
    document.getElementById('addTrackBtn').addEventListener('click', () => {
        addTrack();
    });

    // Metronome toggle
    document.getElementById('metronomeBtn').addEventListener('click', () => {
        const btn = document.getElementById('metronomeBtn');
        if (metronomeInterval) {
            clearInterval(metronomeInterval);
            metronomeInterval = null;
            if (metronomeOsc) {
                metronomeOsc.stop();
                metronomeOsc.disconnect();
                metronomeOsc = null;
            }
            btn.textContent = 'Start Metronome';
        } else {
            const bpm = parseFloat(document.getElementById('bpmInput').value);
            const ctx = getAudioContext();
            const intervalMs = 60000 / bpm;
            const playClick = () => {
                const oscillator = ctx.createOscillator();
                const gain = ctx.createGain();
                oscillator.connect(gain).connect(ctx.destination);
                oscillator.frequency.setValueAtTime(1000, ctx.currentTime);
                gain.gain.setValueAtTime(1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);
                oscillator.start();
                oscillator.stop(ctx.currentTime + 0.05);
            };
            playClick();
            metronomeInterval = setInterval(playClick, intervalMs);
            btn.textContent = 'Stop Metronome';
        }
    });

    // Attach updateGlobalButtons to Track prototype so each instance can call it
    Track.prototype.updateGlobalButtons = updateGlobalButtons;
    </script>
</body>
</html>

